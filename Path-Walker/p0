#!/usr/bin/env perl

use strict;
use warnings;

package GtD;

use Any::Moose;
use Carp;

use Path::Walker;
use Path::Walker::Dispatcher;
#use Carp::Always;

has dispatcher => qw/ is ro lazy_build 1 /, handles => [qw/ plot dispatch /];
sub _build_dispatcher {
    my $self = shift;
    return Path::Walker::Dispatcher->new(
        walker_class => 'GtD::Walker',
        step_class => 'GtD::Step',
        parse_rule => {
            '' => sub { $_[0]->build( 'TokenRegexp' => tokens => [ $_[1] ] ) },
        },
        visitor => sub {
            my %given = @_;
            my $walker = $given{walker};
            my $data = $given{data};
            
            if ( ref $data eq 'CODE' ) {
                return $data->( $walker );
            }
            elsif ( ref $data eq 'GtD::ArgumentSchema' ) {
            }
            else {
                die "Do not know how to visit data (", defined $data ? $data : 'undef', ")";
            }
        },
    );
}

sub is_option_like ($) {
    return $_[0] =~ m/^-/;
}

use Getopt::Long qw/GetOptionsFromArray/;
sub consume_arguments ($$) { # Will modify arguments, reflecting consumption
    my $argument_schema = shift;
    my $arguments = shift;

    my %options;
    eval {
        if ( $argument_schema && @$argument_schema ) {
            Getopt::Long::Configure(qw/ pass_through /);
            GetOptionsFromArray( $arguments, \%options, @$argument_schema );
        }
    };
    croak "There was an error option-processing arguments: $@" if $@;

    return ( \%options );
}

#sub parse_argument_schema {
#    my $self = shift;
#    my $argument_schema = shift;
#    return sub {
#        my $ctx = shift;

#        my $arguments = [ grep { length && m/\S/ } split m/\s/, $ctx->path ];
#        my $options;
#        eval {
#            $options = consume_arguments $argument_schema, $arguments;
#            die "Unknown option-like argument" if @$arguments && is_option_like $arguments->[0];
#        };
#        die $@ if $@;

#        $ctx->set_options( $options );
#        $ctx->local->set_options( $options );
#        $ctx->path( join ' ', @$arguments ); # TODO How should we reconstitute the path?
#    };
#}

package GtD::Walker;

use Any::Moose;

extends qw/Path::Walker::Walker/;

use Hash::MultiValue;

has _options =>
    qw/ is rw isa Hash::MultiValue lazy_build 1 /;
sub _build__options {
    my $self = shift;
    return Hash::MultiValue->new;
}

sub option {
    my $self = shift;
    if ( @_ > 1 ) {
        $self->_options->remove( $_[0] );
        $self->_options->add( @_ );
    }
    return $self->_options->get( $_[0] );
}
sub set_options {
    my $self = shift;
    my $options = shift;
    while (my ($key, $value) = each %$options) {
        $self->_options->remove( $key );
        $self->_options->add( $key => $value );
    }
}

package GtD::Step;

use Any::Moose;

extends qw/Path::Walker::Step/;

use Hash::MultiValue;

has _options =>
    qw/ is rw isa Hash::MultiValue lazy_build 1 /;
sub _build__options {
    my $self = shift;
    return Hash::MultiValue->new;
}

sub option {
    my $self = shift;
    if ( @_ > 1 ) {
        $self->_options->remove( $_[0] );
        $self->_options->add( @_ );
    }
    return $self->_options->get( $_[0] );
}
sub set_options {
    my $self = shift;
    my $options = shift;
    $self->_options( Hash::MultiValue->new( %$options ) );
}

package GtD::ArgumentSchema;

use Any::Moose;

has schema => qw/ is ro isa ArrayRef required 1 /;

1;

package main;

use Test::Most;

plan qw/no_plan/;

my $gtd = GtD->new();

ok( $gtd );
ok( $gtd->dispatcher );

sub arguments ($) {
    return GtD::ArgumentSchema->new( schema => $_[0] );
}

$gtd->plot( 
    "apple", [
        arguments [qw/ a1 b2:s /],
        sub {
            my $ctx = shift;
            diag "At apple\n";
#            ok( $ctx->option( 'a1' ) );
#            is( $ctx->step->option( 'a1' ), '1' );
        },
        "banana", [
            arguments [qw/ a1:s /],
            sub {
                my $ctx = shift;
                diag "At banana\n";
                $ctx->option( 'a1', 'a1' );
    #            is( $ctx->option( 'b2' ), 'b2' );
            },
            "cherry", [
                arguments[qw/ -- /],
                sub {
                    my $ctx = shift;
    #                is( $ctx->path, ' --a2' );
                },
            ],
            sub {
                diag "Post banana\n";
                my $ctx = shift;
    #            is( $ctx->option( 'a1' ), 'a1' );
    #            is( $ctx->step->option( 'a1' ), '1' );
            },
        ],
    ],
);

$gtd->dispatch( "apple --a1 banana --b2 b2" );
$gtd->dispatch( "apple --a1 banana --b2 b2 cherry --a2" );
$gtd->dispatch( "apple banana" );
#$gtd->dispatcher->dispatch( "apple --a1 banana --b2 b2" );
#$gtd->dispatcher->dispatch( "apple --a1 banana --b2 b2 cherry --a2" );

1;
